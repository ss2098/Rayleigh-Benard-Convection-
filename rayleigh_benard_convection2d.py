# -*- coding: utf-8 -*-
"""Rayleigh-Benard-Convection2D.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OS6ZOGF8jivV2a02e-IvYYMfQPUrCT3U
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve
import warnings
warnings.filterwarnings('ignore')

class RayleighBenardConvection2D:
    """
    2D Rayleigh-Bénard Convection Simulation

    Based on the Boussinesq equations used in planetary convection studies:
    - McKinnon et al. (2016): Convection in a volatile nitrogen-ice-rich layer on Pluto
    - Morison et al. (2021): Sublimation-driven convection in Sputnik Planitia on Pluto

    Governing Equations:
    1. Continuity: ∇·u = 0
    2. Momentum: ∂u/∂t + u·∇u = -∇p/ρ₀ + ν∇²u + gαΔTẑ
    3. Energy: ∂T/∂t + u·∇T = κ∇²T

    Where:
    - u = velocity field (u, w)
    - p = pressure
    - T = temperature
    - ρ₀ = reference density
    - ν = kinematic viscosity
    - κ = thermal diffusivity
    - α = thermal expansion coefficient
    - g = gravitational acceleration
    - ΔT = temperature difference
    """

    def __init__(self, nx=128, ny=64, Lx=2.0, Ly=1.0, Ra=10000, Pr=0.71):
        """
        Initialize the simulation parameters

        Parameters:
        -----------
        nx, ny : int
            Grid resolution
        Lx, Ly : float
            Domain size
        Ra : float
            Rayleigh number: Ra = gαΔTH³/(νκ)
        Pr : float
            Prandtl number: Pr = ν/κ
        """
        self.nx, self.ny = nx, ny
        self.Lx, self.Ly = Lx, Ly
        self.Ra = Ra  # Rayleigh number
        self.Pr = Pr  # Prandtl number

        # Grid spacing
        self.dx = Lx / (nx - 1)
        self.dy = Ly / (ny - 1)

        # Coordinate arrays
        self.x = np.linspace(0, Lx, nx)
        self.y = np.linspace(0, Ly, ny)
        self.X, self.Y = np.meshgrid(self.x, self.y)

        # Initialize fields
        self.initialize_fields()

        # Time stepping parameters
        self.dt = min(0.1 * self.dx**2 / (1/self.Pr),
                     0.1 * self.dy**2 / (1/self.Pr))

        print(f"Simulation initialized:")
        print(f"Grid: {nx}×{ny}, Domain: {Lx}×{Ly}")
        print(f"Ra = {Ra:.0f}, Pr = {Pr}")
        print(f"Time step: {self.dt:.6f}")

    def initialize_fields(self):
        """Initialize velocity, temperature, and pressure fields"""
        # Temperature field: linear profile + small perturbations
        # T = 1 at bottom (y=0), T = 0 at top (y=Ly)
        self.T = np.zeros((self.ny, self.nx))
        for j in range(self.ny):
            self.T[j, :] = 1.0 - self.y[j] / self.Ly

        # Add small random perturbations to trigger convection
        # Perturbations are strongest in the middle of the domain
        perturbation = 0.01 * np.random.random((self.ny, self.nx)) * \
                      np.sin(np.pi * self.Y / self.Ly)
        self.T += perturbation

        # Velocity components
        self.u = np.zeros((self.ny, self.nx))  # horizontal velocity
        self.w = np.zeros((self.ny, self.nx))  # vertical velocity

        # Pressure
        self.p = np.zeros((self.ny, self.nx))

        # Vorticity (for visualization)
        self.omega = np.zeros((self.ny, self.nx))

        # Stream function
        self.psi = np.zeros((self.ny, self.nx))

    def apply_boundary_conditions(self):
        """Apply boundary conditions"""
        # Temperature: fixed at boundaries
        self.T[0, :] = 1.0   # Hot bottom
        self.T[-1, :] = 0.0  # Cold top
        self.T[:, 0] = self.T[:, 1]    # Periodic sides
        self.T[:, -1] = self.T[:, -2]

        # Velocity: no-slip at top/bottom, periodic at sides
        self.u[0, :] = 0.0   # Bottom
        self.u[-1, :] = 0.0  # Top
        self.w[0, :] = 0.0   # Bottom
        self.w[-1, :] = 0.0  # Top

        # Periodic boundary conditions for sides
        self.u[:, 0] = self.u[:, -2]
        self.u[:, -1] = self.u[:, 1]
        self.w[:, 0] = self.w[:, -2]
        self.w[:, -1] = self.w[:, 1]

    def compute_derivatives(self, field):
        """Compute first and second derivatives using finite differences"""
        # First derivatives
        dfdx = np.zeros_like(field)
        dfdy = np.zeros_like(field)

        # Central differences (interior points)
        dfdx[:, 1:-1] = (field[:, 2:] - field[:, :-2]) / (2 * self.dx)
        dfdy[1:-1, :] = (field[2:, :] - field[:-2, :]) / (2 * self.dy)

        # Forward/backward differences (boundaries)
        dfdx[:, 0] = (field[:, 1] - field[:, 0]) / self.dx
        dfdx[:, -1] = (field[:, -1] - field[:, -2]) / self.dx
        dfdy[0, :] = (field[1, :] - field[0, :]) / self.dy
        dfdy[-1, :] = (field[-1, :] - field[-2, :]) / self.dy

        # Second derivatives (Laplacian)
        d2fdx2 = np.zeros_like(field)
        d2fdy2 = np.zeros_like(field)

        d2fdx2[:, 1:-1] = (field[:, 2:] - 2*field[:, 1:-1] + field[:, :-2]) / self.dx**2
        d2fdy2[1:-1, :] = (field[2:, :] - 2*field[1:-1, :] + field[:-2, :]) / self.dy**2

        laplacian = d2fdx2 + d2fdy2

        return dfdx, dfdy, laplacian

    def compute_vorticity_streamfunction(self):
        """Compute vorticity and stream function"""
        # Vorticity: ω = ∂w/∂x - ∂u/∂y
        dwdx, _, _ = self.compute_derivatives(self.w)
        _, dudy, _ = self.compute_derivatives(self.u)
        self.omega = dwdx - dudy

        # Solve Poisson equation for stream function: ∇²ψ = -ω
        # Using simple relaxation method
        psi_new = self.psi.copy()
        for _ in range(50):  # Relaxation iterations
            psi_old = psi_new.copy()
            psi_new[1:-1, 1:-1] = 0.25 * (
                psi_old[2:, 1:-1] + psi_old[:-2, 1:-1] +
                psi_old[1:-1, 2:] + psi_old[1:-1, :-2] +
                self.dx**2 * self.omega[1:-1, 1:-1]
            )
            # Boundary conditions for stream function
            psi_new[0, :] = 0
            psi_new[-1, :] = 0
            psi_new[:, 0] = psi_new[:, -2]
            psi_new[:, -1] = psi_new[:, 1]

        self.psi = psi_new

    def time_step(self):
        """Advance one time step using explicit finite difference scheme"""
        # Store old values
        u_old = self.u.copy()
        w_old = self.w.copy()
        T_old = self.T.copy()

        # Compute derivatives
        dudx, dudy, lap_u = self.compute_derivatives(self.u)
        dwdx, dwdy, lap_w = self.compute_derivatives(self.w)
        dTdx, dTdy, lap_T = self.compute_derivatives(self.T)
        dpdx, dpdy, _ = self.compute_derivatives(self.p)

        # Momentum equations (Navier-Stokes with Boussinesq approximation)
        # ∂u/∂t = -u∂u/∂x - w∂u/∂y - ∂p/∂x + (1/Pr)∇²u
        # ∂w/∂t = -u∂w/∂x - w∂w/∂y - ∂p/∂y + (1/Pr)∇²w + Ra*Pr*T

        # Advection terms
        u_adv = u_old * dudx + w_old * dudy
        w_adv = u_old * dwdx + w_old * dwdy
        T_adv = u_old * dTdx + w_old * dTdy

        # Update velocity (explicit scheme)
        self.u = u_old + self.dt * (-u_adv - dpdx + lap_u / self.Pr)
        self.w = w_old + self.dt * (-w_adv - dpdy + lap_w / self.Pr +
                                   self.Ra * self.Pr * T_old)

        # Update temperature
        self.T = T_old + self.dt * (-T_adv + lap_T)

        # Pressure correction (simplified)
        # In practice, this should be done with a proper projection method
        divergence = np.zeros_like(self.p)
        divergence[:, 1:-1] = (self.u[:, 2:] - self.u[:, :-2]) / (2 * self.dx)
        divergence[1:-1, :] += (self.w[2:, :] - self.w[:-2, :]) / (2 * self.dy)

        self.p -= 0.1 * divergence  # Simple pressure correction

        # Apply boundary conditions
        self.apply_boundary_conditions()

        # Compute vorticity and stream function
        self.compute_vorticity_streamfunction()

    def run_simulation(self, steps=1000, save_interval=10):
        """Run the simulation for specified number of steps"""
        print(f"Running simulation for {steps} steps...")

        # Storage for visualization
        self.T_history = []
        self.omega_history = []
        self.psi_history = []
        self.times = []

        for step in range(steps):
            self.time_step()

            if step % save_interval == 0:
                self.T_history.append(self.T.copy())
                self.omega_history.append(self.omega.copy())
                self.psi_history.append(self.psi.copy())
                self.times.append(step * self.dt)

                if step % 100 == 0:
                    print(f"Step {step}, Time = {step * self.dt:.4f}")

        print("Simulation completed!")
        return self.T_history, self.omega_history, self.psi_history, self.times

def create_visualization(conv_sim, T_history, omega_history, psi_history, times):
    """Create visualization of the convection simulation"""
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    fig.suptitle('2D Rayleigh-Bénard Convection Simulation\n'
                f'Ra = {conv_sim.Ra:.0f}, Pr = {conv_sim.Pr}', fontsize=14)

    # Final temperature field
    im1 = axes[0,0].contourf(conv_sim.X, conv_sim.Y, T_history[-1],
                            levels=20, cmap='RdBu_r')
    axes[0,0].set_title('Temperature Field')
    axes[0,0].set_xlabel('x')
    axes[0,0].set_ylabel('y')
    plt.colorbar(im1, ax=axes[0,0])

    # Final vorticity field
    im2 = axes[0,1].contourf(conv_sim.X, conv_sim.Y, omega_history[-1],
                            levels=20, cmap='RdBu')
    axes[0,1].set_title('Vorticity Field')
    axes[0,1].set_xlabel('x')
    axes[0,1].set_ylabel('y')
    plt.colorbar(im2, ax=axes[0,1])

    # Stream function with streamlines
    im3 = axes[1,0].contour(conv_sim.X, conv_sim.Y, psi_history[-1],
                           levels=15, colors='black', linewidths=0.8)
    axes[1,0].set_title('Streamlines')
    axes[1,0].set_xlabel('x')
    axes[1,0].set_ylabel('y')

    # Temperature evolution at center
    y_center_idx = conv_sim.ny // 2
    x_center_idx = conv_sim.nx // 2
    T_center = [T[y_center_idx, x_center_idx] for T in T_history]

    axes[1,1].plot(times, T_center, 'b-', linewidth=2)
    axes[1,1].set_title('Temperature at Domain Center')
    axes[1,1].set_xlabel('Time')
    axes[1,1].set_ylabel('Temperature')
    axes[1,1].grid(True, alpha=0.3)

    plt.tight_layout()
    return fig

def create_animation(conv_sim, T_history, times):
    """Create animation of temperature evolution"""
    fig, ax = plt.subplots(figsize=(12, 6))

    # Set up the plot
    im = ax.contourf(conv_sim.X, conv_sim.Y, T_history[0],
                     levels=20, cmap='RdBu_r', vmin=0, vmax=1)
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title('Temperature Evolution - Rayleigh-Bénard Convection')
    cbar = plt.colorbar(im, ax=ax)
    cbar.set_label('Temperature')

    # Animation function
    def animate(frame):
        ax.clear()
        im = ax.contourf(conv_sim.X, conv_sim.Y, T_history[frame],
                        levels=20, cmap='RdBu_r', vmin=0, vmax=1)
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_title(f'Temperature Evolution - Time = {times[frame]:.3f}')
        return [im]

    # Create animation
    anim = animation.FuncAnimation(fig, animate, frames=len(T_history),
                                  interval=200, blit=False, repeat=True)

    return fig, anim

# Example usage and demonstration   (for validation of parameters values)
if __name__ == "__main__":
    print("=== 2D Rayleigh-Bénard Convection Simulation ===")
    print("Based on planetary convection studies (McKinnon et al. 2016, Morison et al. 2021)")
    print()

    # Create simulation instance
    # Parameters typical for nitrogen ice convection on Pluto
    conv_sim = RayleighBenardConvection2D(
        nx=128,      # Grid resolution
        ny=64,
        Lx=4.0,      # Domain aspect ratio 4:1
        Ly=1.0,
        Ra=50000,    # Rayleigh number (supercritical)
        Pr=0.7       # Prandtl number for nitrogen
    )

    # Run simulation
    T_hist, omega_hist, psi_hist, times = conv_sim.run_simulation(
        steps=2000, save_interval=20
    )

    # Create visualization
    fig = create_visualization(conv_sim, T_hist, omega_hist, psi_hist, times)
    plt.show()

    # Create animation (uncomment to generate)
    # fig_anim, anim = create_animation(conv_sim, T_hist, times)
    # plt.show()

    print("\n=== Simulation Analysis ===")
    print(f"Final Nusselt number estimate: {np.mean(T_hist[-1][0, :]) / np.mean(T_hist[-1][-1, :]):.2f}")
    print(f"Maximum vorticity: {np.max(np.abs(omega_hist[-1])):.3f}")
    print(f"RMS velocity: {np.sqrt(np.mean(conv_sim.u**2 + conv_sim.w**2)):.4f}")

    # Technical equations used in the simulation
    print("\n=== Technical Equations Implemented ===")
    print("1. Continuity Equation: ∇·u = 0")
    print("2. Momentum Equations (Boussinesq):")
    print("   ∂u/∂t + u·∇u = -∇p/ρ₀ + ν∇²u")
    print("   ∂w/∂t + u·∇w = -∇p/ρ₀ + ν∇²w + gαΔT")
    print("3. Energy Equation:")
    print("   ∂T/∂t + u·∇T = κ∇²T")
    print("4. Dimensionless form with:")
    print(f"   Ra = gαΔTH³/(νκ) = {conv_sim.Ra}")
    print(f"   Pr = ν/κ = {conv_sim.Pr}")

